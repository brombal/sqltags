{"mappings":";;;AAIA,SAAS,6BAAO,MAAqB;IACnC,OAAO,eAAe;AACxB;AAEO,SAAS,wCAAS,MAAqB;IAC5C,OAAO;QACL,mBAAkB,MAAW,EAAE,WAAmB;YAChD,OAAO,CAAC,CAAC,EAAE,cAAc,EAAE,CAAC;QAC9B;QAEA,kBAAiB,UAAkB;YACjC,iHAAiH;YACjH,6EAA6E;YAC7E,OAAO,MAAM,WAAW,OAAO,CAAC,MAAM,QAAQ;QAChD;QAEA,+EAA+E;QAC/E,mEAAmE;QACnE,iEAAiE;QACjE,gBAAgB,CAAC,QAAU;QAE3B,OAAO,OAAO,KAAa;YACzB,oEAAoE;YACpE,MAAM,MAAM,MAAM,OAAO,KAAK,CAAC,KAAK;YACpC,yDAAyD;YACzD,OAAO;gBAAC,IAAI,IAAI;gBAAE;aAAI;QACxB;QAEA,QAAQ,SAAU,GAAW,EAAE,MAAa;YAC1C,IAAI;YACJ,IAAI;YACJ,MAAM,QAAe,EAAE;YAEvB,OAAO;gBACL,CAAC,OAAO,aAAa,CAAC,EAAE,IAAO,CAAA;wBAC7B,MAAM;4BACJ,IAAI,CAAC,SAAS;gCACZ,UAAU,6BAAO,UAAU,MAAM,OAAO,OAAO,KAAK;gCACpD,SAAS,QAAQ,KAAK,CAAC,IAAI,CAAA,GAAA,eAAK,EAAE,KAAK;4BACzC;4BAEA,IAAI,MAAM,MAAM,GAAG,GACjB,OAAO;gCAAE,MAAM;gCAAO,OAAO,MAAM,KAAK;4BAAG;4BAG7C,IAAI;gCACF,MAAM,MAAM,MAAM,OAAO,IAAI,CAAC;gCAC9B,IAAI,IAAI,MAAM,KAAK,GAAG;oCACpB,MAAM,OAAO,KAAK;oCAClB,IAAI,6BAAO,SAAS,AAAC,QAAuB,OAAO;oCACnD,OAAO;wCAAE,MAAM;wCAAM,OAAO;oCAAU;gCACxC;gCAEA,MAAM,IAAI,IAAI;gCACd,OAAO;oCAAE,MAAM;oCAAO,OAAO,MAAM,KAAK;gCAAG;4BAC7C,EAAE,OAAM,KAAU;gCAChB,MAAM,OAAO,KAAK;gCAClB,IAAI,6BAAO,SAAS,AAAC,QAAuB,OAAO;gCACnD,MAAM;4BACR;wBACF;oBACF,CAAA;YACF;QACF;IACF;AACF","sources":["drivers/postgres/postgres.ts"],"sourcesContent":["import { type SqlTemplateDriver } from '@sqltags/core';\nimport { type Client, type Pool, type PoolClient, type QueryResult } from 'pg';\nimport Cursor from 'pg-cursor';\n\nfunction isPool(client: Client | Pool): client is Pool {\n  return 'idleCount' in client;\n}\n\nexport function pgDriver(client: Client | Pool): SqlTemplateDriver<QueryResult> {\n  return {\n    parameterizeValue(_value: any, _paramIndex: number) {\n      return `$${_paramIndex + 1}`;\n    },\n\n    escapeIdentifier(identifier: string) {\n      // Not using the one from 'pg' library because it requires a connection instance which doens't work with the pool\n      // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\n      return '\"' + identifier.replace(/\"/g, '\"\"') + '\"';\n    },\n\n    // Note that values are not serialized using the default sqltags serialization.\n    // Instead, they are passed as-is and serialized according to this:\n    // https://node-postgres.com/features/queries#parameterized-query\n    serializeValue: (value) => value,\n\n    query: async (sql: string, params: any[]): Promise<[any[], QueryResult]> => {\n      // const _client = isPool(client) ? await client.connect() : client;\n      const res = await client.query(sql, params);\n      // if (isPool(client)) (_client as PoolClient).release();\n      return [res.rows, res];\n    },\n\n    cursor: function (sql: string, params: any[]): AsyncIterable<any> {\n      let _client: Client | PoolClient;\n      let cursor: Cursor<any>;\n      const queue: any[] = [];\n\n      return {\n        [Symbol.asyncIterator]: () => ({\n          next: async () => {\n            if (!_client) {\n              _client = isPool(client) ? await client.connect() : client;\n              cursor = _client.query(new Cursor(sql, params));\n            }\n\n            if (queue.length > 0) {\n              return { done: false, value: queue.shift() };\n            }\n\n            try {\n              const res = await cursor.read(100);\n              if (res.length === 0) {\n                await cursor.close();\n                if (isPool(client)) (_client as PoolClient).release();\n                return { done: true, value: undefined };\n              }\n\n              queue.push(...res);\n              return { done: false, value: queue.shift() };\n            } catch(err: any) {\n              await cursor.close();\n              if (isPool(client)) (_client as PoolClient).release();\n              throw err;\n            }\n          },\n        }),\n      };\n    },\n  };\n}\n"],"names":[],"version":3,"file":"index.mjs.map","sourceRoot":"../../../"}